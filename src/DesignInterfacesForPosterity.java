import java.util.function.Predicate;

/**
 * Java8之前，在不对已有实现造成影响的情况下向接口添加方法是不可能的，
 * 将新方法添加到接口中后，已有的实现通常会缺少新增方法的实现，导致编译时出现错误。
 * 所有Java8之前默认接口编写好之后，永远不会再向其中添加新的方法。
 * 但Java8添加了default method，便允许我们将新的方法添加到已有实现类的接口中了，
 * 但这种方式仍然风险很大。
 *
 * 默认方法(default method)在接口中声明时，需要一个默认的实现，这个实现会被自动“注入”
 * (injected)到所有未手动实现该方法的、该接口的实现类中，无需实现类编写代码以控制。
 * 这种方式令向现有接口中添加新方法成为可能，但并不能保证这种方法在该接口所有的已有实现中都能正常工作。
 *
 * Java8更新时就向其核心collection接口中添加了很多新的default方法，主要是为了兼容lambda表达式的使用。
 * Java类库中的默认方法质量高，通用性强，绝大多数情况下都能够正常地运行，但这并不表示，
 * 这些默认方法满足了一切可能的需求。比如这个{@link java.util.Collection#removeIf(Predicate)}
 * 默认方法，它通过自己的iterator对集合进行遍历，然后对每一项调用判别式判别，将判别结果符合的项删除掉。
 * 这种方式大概是最好的通用实现了，但却在一些实现类上并不兼容。
 *
 * 其中一个例子是org.apache.commons.collections4.collection.SynchronizedCollection类。这个类跟
 * java.util包中的{@link java.util.Collections.SynchronizedCollection}有相似之处，
 * 但Apache版本用客户端支持的一个对象实现同步控制，而没用集合。换句话说，这是个包装类(wrapper class),
 * 在委托给包装在内的集合之前，会先通过一个对象实现同步控制。这个类仍然在修改之中。写这文章时，
 * 它并没有覆盖removeIf()方法，但removeIf却随着default method机制被注入到这个类之中了。
 * 显然该方法并不能兼容Apache版本的同步控制，于是当我们对其调用removeIf方法时，就有造成并发问题的风险，
 * 有可能抛出{@link java.util.ConcurrentModificationException}或者导致其他异常情况发生。
 *
 * Java类库中为防止这种情况，JDK维护员必须在一些子类中覆盖removeIf()以及其他情况类似的方法的默认实现，
 * 从而能在调用之前实现必要的同步机制。但类库以外的代码就得不到这种维护，往往会出现问题。
 * 默认方法特性被加入后，接口的实现类有时候编译并不报错，但运行时就会出问题。虽然这个现象不很常见，
 * 但一旦出现就会涉及到很多地方(not an isolated incident)。Java8中添加到Collections接口中的方法里面，
 * 有一些容易受到影响，也有一些已经受到影响了。(?? 什么影响)
 *
 * 除非超级超级有必要而且又经过了认真全面详细的考虑(尤其是对“是否会破坏已有实现类”的考虑)，
 * 否则就应尽量避免用default method往现有接口中添加新的方法。不过，当创建新的接口时，
 * default method就非常有用了，它可以极大地减少实现该接口时的工作量。
 *
 * 还应注意，default method虽然可以在不影响实现类编译的前提下，向已有接口中新增方法，
 * 但并不可以在不破坏客户端的同时删除接口方法，或者修改方法的签名。
 * 这也意味着不可以因为default method的加入，而在设计接口时草草了事儿，谨慎设计接口仍然十分有必要，
 * 因为通过default method添加新方法要冒极大风险，而且Interface的缺陷会给使用者带来无穷无尽的麻烦。
 *
 * 因此，在设计好接口后，十分有必要在release版本发布前好好测试一下它，方案还是分别实现三次，
 * 让实现类执行各种可能的任务，然后找不足。至少有一个实现类中，编写实现类的人跟接口的设计者不是同一个人。
 * 这时候如果发现错误，可以很容易地纠正它们，而发布之后，虽然有些缺陷仍然可以通过某些途径纠正，
 * 但最好不要指望这么干。
 *
 *
 * @author LightDance
 */
public class DesignInterfacesForPosterity {
    //没有代码
}
